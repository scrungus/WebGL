<html>
	<head>
		<title>CM20219 – Coursework 2 – WebGL</title>
        <meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body { margin: 0; overflow: hidden; }
			canvas { width: 100%; height: 100%; }
		</style>
	</head>
	<body>
		<script type="module">
            "use strict"; // https://stackoverflow.com/q/1335851/72470
            import * as THREE from './js/three.module.js';
            import { OBJLoader } from './js/OBJLoader.js';
            // Global variables that are available in all functions.
            // Note: You can add your own here, e.g. to store the rendering mode.
            //import { OBJLoader } from 'OBJLoader.js';
            var camera, scene, renderer, mesh, cube, bunny, loader,mouseButtonDown,mousePosX,mousePosY, lookAt;

            // Listen for keyboard events, to react to them.
            // Note: there are also other event listeners, e.g. for mouse events.
            document.addEventListener('keydown', handleKeyDown);
            
            //Mouse Scroll event 
            document.addEventListener('wheel',handleScroll);

            //arcball-mode camera listeners
            document.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // Initialise the scene, and draw it for the first time.
            init();
			animate();
            // Scene initialisation. This function is only run once, at the very beginning.
            function init()
            {
                scene = new THREE.Scene();

                // Set up the camera, move it to (3, 4, 5) and look at the origin (0, 0, 0).
                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(3, 4, 5);
                lookAt = new THREE.Vector3(0,0,0);
                camera.lookAt(new THREE.Vector3(0, 0, 0));

                // Draw a helper grid in the x-z plane (note: y is up).
                scene.add(new THREE.GridHelper(10, 20, 0xffffff));

                // TO DO: Draw a cube (requirement 1).
                //Basic Cube 
                var boxGeo = new THREE.CubeGeometry(2,2,2);
                var boxMat = createDiceTexture();
                cube = new THREE.Mesh(boxGeo,boxMat);
                cube.castShadow = true;
                scene.add(cube);
                // TO DO: Visualise the axes of the global coordinate system (requirment 2).
                var axesHelper = new THREE.AxesHelper(20);
                scene.add(axesHelper);
                // Basic ambient lighting.
                scene.add(new THREE.AmbientLight(0xffffff));
                // TO DO: add more complex lighting for 'face' rendering mode (requirement 4).

                //load bunny in
                loader = new OBJLoader();
                loadBunny();

                //adding plane 
                var planGeo = new THREE.PlaneGeometry( 20, 20, 20 );
                var planMat = new THREE.MeshPhongMaterial( { color: 0xcccccc } );
                var plane = new THREE.Mesh(planGeo,planMat);
                plane.rotateX(-Math.PI * 0.5);
                plane.position.set(0,-2,0);
                plane.receiveShadow = true;
                //scene.add(plane);

                //Light to cause shadows
                var light = new THREE.SpotLight(0xffffff);
                light.position.set(-3, 4, -5);
                light.castShadow = true; 
                light.intensity = 1;
                scene.add(light);
                
                // Set up the Web GL renderer.
                renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio); // HiDPI/retina rendering
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                document.body.appendChild(renderer.domElement);

                // Handle resizing of the browser window.
				window.addEventListener('resize', handleResize, false);
            }
            // Handle resizing of the browser window.
            function handleResize()
            {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

            function rotateCube(){
                    cube.rotation.x -= 0.01;
                    cube.rotation.y -= 0.01;
                    cube.rotation.z -= 0.01;
            }

            function rotateBunny(){
                if(bunny){
                    bunny.rotation.x += 0.01;
                    bunny.rotation.y += 0.01;
                    bunny.rotation.z += 0.01;
                }
            }

            function loadBunny(renderMode){
                loader.load(
                    'bunny-5000.obj', 
                    function ( object ) {
                        if(renderMode == 'e'){
                            object.traverse( function ( child ) {

                                if(child.material)
    
                                {
                                    child.material.wireframe = true;
                                    child.material.color.setHex(0xfffff);
                                }
    
                            } );
                        } 
                        else if(renderMode == 'v'){
                            var bunnyMaterial = new THREE.PointsMaterial( { color: 0xfffff , size: 0.01 } );
                            object = new THREE.Points(object.children[0].geometry, bunnyMaterial);
                        }  
                        object.scale.x = object.scale.y = object.scale.z = 0.3;
                        scene.add( object );
                        bunny = object;           
                    }
                );
            }
            
            // Animation loop function. This function is called whenever an update is required.
			function animate()
            {
				requestAnimationFrame(animate);
                // TO DO: This is a good place for code that rotates your cube (requirement 3).
                rotateCube();
                rotateBunny();
                // Render the current scene to the screen.
				renderer.render(scene, camera);
			}

            function createDiceTexture()
            {
                var texLoader = new THREE.TextureLoader();

                var face1 = texLoader.load('./textures/1.png');
                var face2 = texLoader.load('./textures/2.png');
                var face3 = texLoader.load('./textures/3.png');
                var face4 = texLoader.load('./textures/4.png');
                var face5 = texLoader.load('./textures/5.png');
                var face6 = texLoader.load('./textures/6.png');

                var faces = [
                    new THREE.MeshBasicMaterial({map: face1}),
                    new THREE.MeshBasicMaterial({map: face2}),
                    new THREE.MeshBasicMaterial({map: face3}),
                    new THREE.MeshBasicMaterial({map: face4}),
                    new THREE.MeshBasicMaterial({map: face5}),
                    new THREE.MeshBasicMaterial({map: face6})
                ]

                var boxMat = new THREE.MeshFaceMaterial(faces);
                return boxMat;
            }
            // Handle keyboard presses.
            function handleKeyDown(event)
            {
                switch (event.keyCode)
                {
                    // Render modes.
                    case 70: // f = face
                        scene.remove(cube);
                        scene.remove(bunny);

                        var boxGeo = new THREE.CubeGeometry(2,2,2);
                        var boxMat = createDiceTexture();
                        cube = new THREE.Mesh(boxGeo,boxMat);
                        cube.castShadow = true;
                        cube.receiveShadow = true;    
                        loadBunny();

                        scene.add(cube);
                        break;

                    case 69: // e = edge
                        scene.remove(cube);
                        scene.remove(bunny);
                        var boxGeo = new THREE.CubeGeometry(2,2,2);
                        var edgeGeo = new THREE.EdgesGeometry(boxGeo);
                        var edgeMat = new THREE.LineBasicMaterial( { color: 0xfffff } );
                        cube = new THREE.LineSegments(edgeGeo, edgeMat);
                        cube.castShadow = true;
                        cube.receiveShadow = true;    
                        loadBunny('e');
                        
                        scene.add(cube);
                        break;

                    case 86: // v = vertex
                        scene.remove(cube);
                        scene.remove(bunny);

                        var boxGeo = new THREE.CubeGeometry(2,2,2);
                        var vertMat = new THREE.PointsMaterial({color: 0xfffff, size: 0.1});
                        cube = new THREE.Points(boxGeo,vertMat);
                        cube.castShadow = true;
                        cube.receiveShadow = true;  
                        loadBunny('v');
                        scene.add(cube);
                        break;

                    case 38: //Translate Camera UP (UP Arrow Key)
                        camera.translateY(1);
                        lookAt.y += 1;
                        break;

                    case 40: //Translate Camera DOWN (DOWN Arrow Key)
                        camera.translateY(-1);
                        lookAt.y += -1;
                        break;

                    case 37: //Translate Camera LEFT (LEFT Arrow Key)
                        camera.translateX(-1);
                        lookAt.x += -1;
                        break;

                    case 39: //Translate Camera RIGHT (RIGHT Arrow Key)
                        camera.translateX(1);
                        lookAt.x += 1;
                        break;
                    // TO DO: add code for starting/stopping rotations (requirement 3).
                }
            }

            //Handle scrolling
            function handleScroll(event){
                camera.translateZ(event.deltaY);
                lookAt.z += event.deltaY;
            }

            function handleMouseDown(event){
                mouseButtonDown = event.button;
                mousePosX = event.clientX;
                mousePosY = event.clientY;
                event.preventDefault();
            }
                
            function handleMouseMove(event){
                var cam = camera.position;
                var radius = cam.distanceTo( lookAt );

                //spherical coordinates
                var theta = Math.acos(cam.y/radius);
                var phi = Math.atan2(cam.z,cam.x);

                if(mouseButtonDown == 0){
                    //we can increase/decrease theta and phi to move the camera about the sphere
                    phi += (event.x - mousePosX)/100;
                    theta += (event.y - mousePosY)/100;
                    theta = Math.min(Math.PI - 10**(-6), Math.max(10**(-6), theta));

                    cam = new THREE.Vector3(radius*Math.sin(theta)*Math.cos(phi), radius*Math.cos(theta), radius*Math.sin(theta)*Math.sin(phi));
                    
                    camera.position.copy( lookAt.clone().add(cam) );

                    mousePosX = event.x;
                    mousePosY = event.y;
                    mousePosX = event.clientX;

                    camera.lookAt(lookAt);
                }
            }
            
            function handleMouseUp(event){
                mouseButtonDown=-1;
            }

		</script>
	</body>
</html>